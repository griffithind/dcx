package build

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/griffithind/dcx/internal/common"
	"github.com/griffithind/dcx/internal/features"
)

// BuildWithFeatures builds a derived image with features installed.
// Uses BuildKit build contexts for efficient feature content delivery.
func (b *CLIBuilder) BuildWithFeatures(ctx context.Context, opts FeatureBuildOptions) (string, error) {
	if len(opts.Features) == 0 {
		// No features to install, return base image
		return opts.BaseImage, nil
	}

	// Check if derived image already exists and is up-to-date
	if !opts.Rebuild {
		exists, err := b.ImageExists(ctx, opts.Tag)
		if err == nil && exists {
			fmt.Printf("Using cached derived image\n")
			return opts.Tag, nil
		}
	}

	// Print header with feature list
	fmt.Printf("Building derived image with %d feature(s)\n", len(opts.Features))
	for i, f := range opts.Features {
		name := f.ID
		if f.Metadata != nil && f.Metadata.Name != "" {
			name = f.Metadata.Name
		}
		fmt.Printf(" => %d. %s\n", i+1, name)
	}

	// Create temporary directories:
	// - buildContextDir: contains only the Dockerfile (minimal build context)
	// - featureSourceDir: contains staged feature files (passed via --build-context)
	tempDir, err := os.MkdirTemp("", "dcx-build-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	buildContextDir := filepath.Join(tempDir, "context")
	featureSourceDir := filepath.Join(tempDir, "features")

	if err := os.MkdirAll(buildContextDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create build context directory: %w", err)
	}
	if err := os.MkdirAll(featureSourceDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create feature source directory: %w", err)
	}

	// Resolve user settings
	containerUser := opts.ContainerUser
	if containerUser == "" {
		containerUser = "root"
	}
	remoteUser := opts.RemoteUser
	if remoteUser == "" {
		remoteUser = containerUser
	}

	// Generate metadata for the derived image
	metadataLabel, err := GenerateMetadataLabel(
		opts.BaseImageMetadata,
		opts.Features,
		opts.LocalConfig,
	)
	if err != nil {
		return "", fmt.Errorf("failed to generate metadata: %w", err)
	}

	// Generate Dockerfile using the features package
	generator := features.NewDockerfileGenerator(opts.BaseImage, opts.Features, buildContextDir, remoteUser, containerUser)
	generator.SetMetadata(metadataLabel)
	dockerfile := generator.Generate()

	// Write Dockerfile to build context
	dockerfilePath := filepath.Join(buildContextDir, "Dockerfile.dcx-features")
	if err := os.WriteFile(dockerfilePath, []byte(dockerfile), 0644); err != nil {
		return "", fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	// Stage features to feature source directory (for --build-context)
	if err := stageFeatures(opts.Features, featureSourceDir, containerUser, remoteUser); err != nil {
		return "", fmt.Errorf("failed to stage features: %w", err)
	}

	// Build the image using Docker CLI with BuildKit build context
	_, err = b.BuildFromDockerfile(ctx, DockerfileBuildOptions{
		Tag:        opts.Tag,
		Dockerfile: "Dockerfile.dcx-features",
		Context:    buildContextDir,
		BuildContexts: map[string]string{
			"dev_containers_feature_content_source": featureSourceDir,
		},
	})
	if err != nil {
		return "", fmt.Errorf("failed to build derived image: %w", err)
	}

	return opts.Tag, nil
}

// stageFeatures copies feature directories and generates builtin.env for the build context.
func stageFeatures(featureList []*features.Feature, destDir string, containerUser, remoteUser string) error {
	// Copy each feature directory
	for i, feature := range featureList {
		featureDir := filepath.Join(destDir, fmt.Sprintf("feature_%d", i))
		if err := copyDir(feature.CachePath, featureDir); err != nil {
			return fmt.Errorf("failed to copy feature %s: %w", feature.ID, err)
		}
	}

	// Generate builtin.env with home directory resolution script
	builtinEnvContent := generateBuiltinEnv(containerUser, remoteUser)
	builtinEnvPath := filepath.Join(destDir, "builtin.env")
	if err := os.WriteFile(builtinEnvPath, []byte(builtinEnvContent), 0644); err != nil {
		return fmt.Errorf("failed to write builtin.env: %w", err)
	}

	return nil
}

// generateBuiltinEnv creates the content for builtin.env file.
// This file is sourced by feature install scripts to get user/home environment.
func generateBuiltinEnv(containerUser, remoteUser string) string {
	containerUserHome := common.GetDefaultHomeDir(containerUser)
	remoteUserHome := common.GetDefaultHomeDir(remoteUser)

	return fmt.Sprintf(`#!/bin/sh
# Builtin environment for devcontainer features
# Generated by dcx

export _CONTAINER_USER="%s"
export _CONTAINER_USER_HOME="%s"
export _REMOTE_USER="%s"
export _REMOTE_USER_HOME="%s"
`, containerUser, containerUserHome, remoteUser, remoteUserHome)
}

// copyDir copies a directory recursively.
func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Calculate destination path
		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		dstPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}

		// Copy file
		data, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		return os.WriteFile(dstPath, data, info.Mode())
	})
}
