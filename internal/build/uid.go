package build

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strconv"

	"github.com/griffithind/dcx/internal/devcontainer"
)

// updateUIDDockerfile is the Dockerfile template for updating user UID/GID.
// This matches the devcontainers/cli reference implementation.
// See: https://github.com/devcontainers/cli/blob/main/scripts/updateUID.Dockerfile
const updateUIDDockerfile = `# Generated by dcx - UID update layer
ARG BASE_IMAGE
FROM ${BASE_IMAGE}

USER root

ARG REMOTE_USER
ARG NEW_UID
ARG NEW_GID
SHELL ["/bin/sh", "-c"]
RUN eval $(sed -n "s/${REMOTE_USER}:[^:]*:\([^:]*\):\([^:]*\):[^:]*:\([^:]*\).*/OLD_UID=\1;OLD_GID=\2;HOME_FOLDER=\3/p" /etc/passwd); \
	eval $(sed -n "s/\([^:]*\):[^:]*:${NEW_UID}:.*/EXISTING_USER=\1/p" /etc/passwd); \
	eval $(sed -n "s/\([^:]*\):[^:]*:${NEW_GID}:.*/EXISTING_GROUP=\1/p" /etc/group); \
	if [ -z "$OLD_UID" ]; then \
		echo "Remote user not found in /etc/passwd ($REMOTE_USER)."; \
	elif [ "$OLD_UID" = "$NEW_UID" -a "$OLD_GID" = "$NEW_GID" ]; then \
		echo "UIDs and GIDs are the same ($NEW_UID:$NEW_GID)."; \
	elif [ "$OLD_UID" != "$NEW_UID" -a -n "$EXISTING_USER" ]; then \
		echo "User with UID exists ($EXISTING_USER=$NEW_UID)."; \
	else \
		if [ "$OLD_GID" != "$NEW_GID" -a -n "$EXISTING_GROUP" ]; then \
			echo "Group with GID exists ($EXISTING_GROUP=$NEW_GID)."; \
			NEW_GID="$OLD_GID"; \
		fi; \
		echo "Updating UID:GID from $OLD_UID:$OLD_GID to $NEW_UID:$NEW_GID."; \
		sed -i -e "s/\(${REMOTE_USER}:[^:]*:\)[^:]*:[^:]*/\1${NEW_UID}:${NEW_GID}/" /etc/passwd; \
		if [ "$OLD_GID" != "$NEW_GID" ]; then \
			sed -i -e "s/\([^:]*:[^:]*:\)${OLD_GID}:/\1${NEW_GID}:/" /etc/group; \
		fi; \
		chown -R $NEW_UID:$NEW_GID $HOME_FOLDER; \
	fi;

# Preserve metadata from base image
ARG METADATA_LABEL
LABEL devcontainer.metadata=${METADATA_LABEL}

ARG IMAGE_USER
USER $IMAGE_USER
`

// BuildUIDUpdate builds an image with updated UID/GID for the remote user.
func (b *CLIBuilder) BuildUIDUpdate(ctx context.Context, opts UIDBuildOptions) (string, error) {
	// Validate inputs
	if opts.BaseImage == "" {
		return "", fmt.Errorf("baseImage is required for UID update")
	}
	if opts.RemoteUser == "" {
		return "", fmt.Errorf("remoteUser is required for UID update")
	}

	// Check if UID update is needed
	if !ShouldUpdateRemoteUserUID(opts.RemoteUser, opts.HostUID) {
		return opts.BaseImage, nil
	}

	// Check if image already exists
	if !opts.Rebuild {
		exists, err := b.ImageExists(ctx, opts.Tag)
		if err == nil && exists {
			fmt.Printf("[+] Using cached UID image\n")
			return opts.Tag, nil
		}
	}

	fmt.Printf("[+] Updating UID/GID to %d:%d for user %s\n",
		opts.HostUID, opts.HostGID, opts.RemoteUser)

	// Get metadata from base image if not provided
	metadata := opts.Metadata
	if metadata == "" {
		labels, err := b.GetImageLabels(ctx, opts.BaseImage)
		if err == nil && labels != nil {
			metadata = labels[devcontainer.DevcontainerMetadataLabel]
		}
	}

	// Create temporary build directory
	tempBuildDir, err := os.MkdirTemp("", "dcx-updateuid-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temp build directory: %w", err)
	}
	defer os.RemoveAll(tempBuildDir)

	// Write the Dockerfile
	dockerfilePath := filepath.Join(tempBuildDir, "Dockerfile.updateuid")
	if err := os.WriteFile(dockerfilePath, []byte(updateUIDDockerfile), 0644); err != nil {
		return "", fmt.Errorf("failed to write updateUID Dockerfile: %w", err)
	}

	// If imageUser is empty, default to remoteUser
	imageUser := opts.ImageUser
	if imageUser == "" {
		imageUser = opts.RemoteUser
	}

	// Build the image using Docker CLI
	_, err = b.BuildFromDockerfile(ctx, DockerfileBuildOptions{
		Tag:        opts.Tag,
		Dockerfile: dockerfilePath,
		Context:    tempBuildDir,
		Args: map[string]string{
			"BASE_IMAGE":     opts.BaseImage,
			"REMOTE_USER":    opts.RemoteUser,
			"NEW_UID":        strconv.Itoa(opts.HostUID),
			"NEW_GID":        strconv.Itoa(opts.HostGID),
			"IMAGE_USER":     imageUser,
			"METADATA_LABEL": metadata,
		},
	})
	if err != nil {
		return "", fmt.Errorf("failed to build UID update image: %w", err)
	}

	return opts.Tag, nil
}

// ShouldUpdateRemoteUserUID determines if we should update the remote user's UID.
// This is called during the build phase to decide whether to add the UID update layer.
//
// Returns true when:
//   - Platform is Linux or macOS (Darwin)
//   - Host user is not root (UID 0)
//   - remoteUser is not "root"
func ShouldUpdateRemoteUserUID(remoteUser string, hostUID int) bool {
	// Skip on Windows (different file sharing semantics)
	if runtime.GOOS == "windows" {
		return false
	}

	// Skip if host is root
	if hostUID == 0 {
		return false
	}

	// Skip if remote user is root
	if remoteUser == "root" || remoteUser == "0" {
		return false
	}

	return true
}

// ShouldUpdateRemoteUserUIDWithConfig determines if we should update the remote user's UID.
// This version accepts the explicit updateRemoteUserUID config option.
//
// Parameters:
//   - updateRemoteUserUID: the value from devcontainer.json (nil means use default)
//   - remoteUser: the user whose UID/GID should be updated (e.g., "vscode")
//   - hostUID: the host user's UID to match
//
// Returns true when:
//   - Platform is Linux or macOS (Darwin)
//   - Host user is not root (UID 0)
//   - updateRemoteUserUID is not explicitly disabled
//   - remoteUser is not "root"
func ShouldUpdateRemoteUserUIDWithConfig(updateRemoteUserUID *bool, remoteUser string, hostUID int) bool {
	// Skip on Windows (different file sharing semantics)
	if runtime.GOOS == "windows" {
		return false
	}

	// Skip if host is root
	if hostUID == 0 {
		return false
	}

	// Skip if remote user is root
	if remoteUser == "root" || remoteUser == "0" {
		return false
	}

	// If explicitly set in config, use that value
	if updateRemoteUserUID != nil {
		return *updateRemoteUserUID
	}

	// Default to true on Linux and macOS
	return true
}
