package features

import (
	"fmt"
	"path/filepath"
	"strings"
)

// DockerfileGenerator generates Dockerfiles for feature installation.
type DockerfileGenerator struct {
	baseImage         string
	features          []*Feature
	buildDir          string
	remoteUser        string
	remoteUserHome    string
	containerUser     string
	containerUserHome string
}

// NewDockerfileGenerator creates a new Dockerfile generator.
// remoteUser is the configured remoteUser from devcontainer.json (defaults to containerUser if empty).
// containerUser is the container's user account (defaults to "root" if empty).
func NewDockerfileGenerator(baseImage string, features []*Feature, buildDir, remoteUser, containerUser string) *DockerfileGenerator {
	// Container user defaults to root
	if containerUser == "" {
		containerUser = "root"
	}
	containerUserHome := "/root"
	if containerUser != "root" {
		containerUserHome = "/home/" + containerUser
	}

	// Remote user defaults to container user per spec
	if remoteUser == "" {
		remoteUser = containerUser
	}
	remoteUserHome := "/root"
	if remoteUser != "root" {
		remoteUserHome = "/home/" + remoteUser
	}

	return &DockerfileGenerator{
		baseImage:         baseImage,
		features:          features,
		buildDir:          buildDir,
		remoteUser:        remoteUser,
		remoteUserHome:    remoteUserHome,
		containerUser:     containerUser,
		containerUserHome: containerUserHome,
	}
}

// Generate creates the Dockerfile content.
func (g *DockerfileGenerator) Generate() string {
	var sb strings.Builder

	// BuildKit syntax directive (must be first line for SSH mount support)
	sb.WriteString("# syntax=docker/dockerfile:1\n")

	// Header comment
	sb.WriteString("# Generated by dcx - do not edit\n")
	sb.WriteString("# This Dockerfile installs devcontainer features on the base image\n\n")

	// Start from base image
	sb.WriteString(fmt.Sprintf("FROM %s\n\n", g.baseImage))

	// Set build-time arguments for feature installation per devcontainer spec
	sb.WriteString("# Feature installation environment\n")
	sb.WriteString(fmt.Sprintf("ARG _REMOTE_USER=%s\n", g.remoteUser))
	sb.WriteString(fmt.Sprintf("ARG _REMOTE_USER_HOME=%s\n", g.remoteUserHome))
	sb.WriteString(fmt.Sprintf("ARG _CONTAINER_USER=%s\n", g.containerUser))
	sb.WriteString(fmt.Sprintf("ARG _CONTAINER_USER_HOME=%s\n\n", g.containerUserHome))

	// Install each feature
	for i, feature := range g.features {
		g.generateFeatureInstall(&sb, feature, i)
	}

	// Collect environment variables from all features
	envVars := g.collectContainerEnv()
	if len(envVars) > 0 {
		sb.WriteString("# Container environment from features\n")
		for key, value := range envVars {
			sb.WriteString(fmt.Sprintf("ENV %s=%s\n", key, shellQuote(value)))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateFeatureInstall generates the installation commands for a single feature.
func (g *DockerfileGenerator) generateFeatureInstall(sb *strings.Builder, feature *Feature, index int) {
	featureName := feature.ID
	if feature.Metadata != nil && feature.Metadata.Name != "" {
		featureName = feature.Metadata.Name
	}

	sb.WriteString(fmt.Sprintf("# Feature %d: %s\n", index+1, featureName))

	// Copy feature files
	featureDir := fmt.Sprintf("feature_%d", index)
	sb.WriteString(fmt.Sprintf("COPY %s /tmp/dcx-features/%s\n", featureDir, featureDir))

	// Set option environment variables as build args (not persisted in image)
	envVars := feature.GetEnvVars()
	if len(envVars) > 0 {
		for key, value := range envVars {
			sb.WriteString(fmt.Sprintf("ARG %s=%s\n", key, shellQuote(value)))
		}
	}

	// Run install.sh - use the script's shebang (features typically require bash)
	sb.WriteString(fmt.Sprintf("RUN chmod +x /tmp/dcx-features/%s/install.sh && \\\n", featureDir))
	sb.WriteString(fmt.Sprintf("    cd /tmp/dcx-features/%s && \\\n", featureDir))
	sb.WriteString("    ./install.sh && \\\n")
	sb.WriteString(fmt.Sprintf("    rm -rf /tmp/dcx-features/%s\n\n", featureDir))
}

// collectContainerEnv collects all containerEnv values from features.
func (g *DockerfileGenerator) collectContainerEnv() map[string]string {
	env := make(map[string]string)

	for _, feature := range g.features {
		if feature.Metadata == nil {
			continue
		}
		for key, value := range feature.Metadata.ContainerEnv {
			env[key] = value
		}
	}

	return env
}

// GetFeaturePaths returns the source paths for features to be copied into the build context.
func (g *DockerfileGenerator) GetFeaturePaths() []FeatureCopyPath {
	paths := make([]FeatureCopyPath, len(g.features))

	for i, feature := range g.features {
		paths[i] = FeatureCopyPath{
			Source: feature.CachePath,
			Dest:   fmt.Sprintf("feature_%d", i),
		}
	}

	return paths
}

// FeatureCopyPath represents a feature directory to copy into the build context.
type FeatureCopyPath struct {
	Source string // Absolute path to feature directory
	Dest   string // Destination directory name in build context
}

// collectUniqueStrings is a generic helper to collect unique strings from features.
func collectUniqueStrings(features []*Feature, getStrings func(*FeatureMetadata) []string) []string {
	seen := make(map[string]bool)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, s := range getStrings(feature.Metadata) {
			seen[s] = true
		}
	}

	result := make([]string, 0, len(seen))
	for s := range seen {
		result = append(result, s)
	}

	return result
}

// CollectCapabilities collects all capabilities needed by features.
func CollectCapabilities(features []*Feature) []string {
	return collectUniqueStrings(features, func(m *FeatureMetadata) []string {
		return m.CapAdd
	})
}

// CollectSecurityOpts collects all security options needed by features.
func CollectSecurityOpts(features []*Feature) []string {
	return collectUniqueStrings(features, func(m *FeatureMetadata) []string {
		return m.SecurityOpt
	})
}

// NeedsPrivileged returns true if any feature requires privileged mode.
func NeedsPrivileged(features []*Feature) bool {
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Privileged {
			return true
		}
	}
	return false
}

// GetPrivilegedFeatures returns the names of features that require privileged mode.
func GetPrivilegedFeatures(features []*Feature) []string {
	var names []string
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Privileged {
			name := feature.Metadata.Name
			if name == "" {
				name = feature.Metadata.ID
			}
			names = append(names, name)
		}
	}
	return names
}

// SecurityRequirements summarizes the security requirements from features.
type SecurityRequirements struct {
	Privileged   bool
	Capabilities []string
	SecurityOpts []string
	FeatureNames []string // Features that require elevated privileges
}

// GetSecurityRequirements returns all security requirements from features.
func GetSecurityRequirements(features []*Feature) SecurityRequirements {
	reqs := SecurityRequirements{}

	capMap := make(map[string]bool)
	optMap := make(map[string]bool)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}

		name := feature.Metadata.Name
		if name == "" {
			name = feature.Metadata.ID
		}

		if feature.Metadata.Privileged {
			reqs.Privileged = true
			reqs.FeatureNames = append(reqs.FeatureNames, name+" (privileged)")
		}

		for _, cap := range feature.Metadata.CapAdd {
			if !capMap[cap] {
				capMap[cap] = true
				reqs.Capabilities = append(reqs.Capabilities, cap)
			}
		}

		for _, opt := range feature.Metadata.SecurityOpt {
			if !optMap[opt] {
				optMap[opt] = true
				reqs.SecurityOpts = append(reqs.SecurityOpts, opt)
			}
		}
	}

	return reqs
}

// NeedsInit returns true if any feature requires init.
func NeedsInit(features []*Feature) bool {
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Init {
			return true
		}
	}
	return false
}

// MountSubstituteFunc is a function that performs variable substitution on mount strings.
type MountSubstituteFunc func(string) string

// CollectMounts collects all mounts needed by features.
// If substitute is provided, it will be applied to each mount string for variable substitution.
func CollectMounts(features []*Feature, substitute MountSubstituteFunc) []string {
	mounts := make([]string, 0)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, m := range feature.Metadata.Mounts {
			mount := m.String()
			if substitute != nil {
				mount = substitute(mount)
			}
			mounts = append(mounts, mount)
		}
	}

	return mounts
}

// CollectContainerEnv collects all container environment variables from features.
func CollectContainerEnv(features []*Feature) map[string]string {
	env := make(map[string]string)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for key, value := range feature.Metadata.ContainerEnv {
			env[key] = value
		}
	}

	return env
}

// FeatureHook represents a lifecycle hook from a feature.
type FeatureHook struct {
	// FeatureID identifies which feature this hook is from
	FeatureID string
	// FeatureName is the display name of the feature
	FeatureName string
	// Command is the command specification (string, array, or map)
	Command interface{}
}

// HookType represents a lifecycle hook type.
type HookType string

const (
	HookOnCreate      HookType = "onCreateCommand"
	HookUpdateContent HookType = "updateContentCommand"
	HookPostCreate    HookType = "postCreateCommand"
	HookPostStart     HookType = "postStartCommand"
	HookPostAttach    HookType = "postAttachCommand"
)

// CollectHooks collects lifecycle hooks of the specified type from features.
// This is the generic form that can be used instead of the specific CollectXCommands functions.
func CollectHooks(features []*Feature, hookType HookType) []FeatureHook {
	var getter func(*FeatureMetadata) interface{}

	switch hookType {
	case HookOnCreate:
		getter = func(m *FeatureMetadata) interface{} { return m.OnCreateCommand }
	case HookUpdateContent:
		getter = func(m *FeatureMetadata) interface{} { return m.UpdateContentCommand }
	case HookPostCreate:
		getter = func(m *FeatureMetadata) interface{} { return m.PostCreateCommand }
	case HookPostStart:
		getter = func(m *FeatureMetadata) interface{} { return m.PostStartCommand }
	case HookPostAttach:
		getter = func(m *FeatureMetadata) interface{} { return m.PostAttachCommand }
	default:
		return nil
	}

	return collectHooks(features, getter)
}

// collectHooks is a generic helper to collect lifecycle hooks from features.
func collectHooks(features []*Feature, getCommand func(*FeatureMetadata) interface{}) []FeatureHook {
	var hooks []FeatureHook
	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		cmd := getCommand(feature.Metadata)
		if cmd == nil {
			continue
		}
		name := feature.Metadata.Name
		if name == "" {
			name = feature.Metadata.ID
		}
		hooks = append(hooks, FeatureHook{
			FeatureID:   feature.Metadata.ID,
			FeatureName: name,
			Command:     cmd,
		})
	}
	return hooks
}

// CollectOnCreateCommands collects all onCreateCommand hooks from features.
// These run after feature installation, in feature order.
func CollectOnCreateCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookOnCreate)
}

// CollectPostCreateCommands collects all postCreateCommand hooks from features.
// These run after all features are installed and container is ready.
func CollectPostCreateCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookPostCreate)
}

// CollectPostStartCommands collects all postStartCommand hooks from features.
// These run on each container start.
func CollectPostStartCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookPostStart)
}

// CollectUpdateContentCommands collects all updateContentCommand hooks from features.
// These run after onCreateCommand and before postCreateCommand.
func CollectUpdateContentCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookUpdateContent)
}

// CollectPostAttachCommands collects all postAttachCommand hooks from features.
// These run when attaching to the container.
func CollectPostAttachCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookPostAttach)
}

// shellQuote quotes a string for use in shell.
func shellQuote(s string) string {
	// If string contains no special characters, return as-is
	if !strings.ContainsAny(s, " \t\n\"'$`\\!") {
		return s
	}

	// Use double quotes and escape special characters
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "$", "\\$")
	s = strings.ReplaceAll(s, "`", "\\`")

	return fmt.Sprintf("\"%s\"", s)
}

// PrepareBuildContext creates the build context directory with feature files.
func PrepareBuildContext(buildDir string, features []*Feature, dockerfile string) error {
	// Write Dockerfile
	dockerfilePath := filepath.Join(buildDir, "Dockerfile.dcx-features")
	if err := writeFile(dockerfilePath, []byte(dockerfile)); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	// Copy feature directories
	for i, feature := range features {
		destDir := filepath.Join(buildDir, fmt.Sprintf("feature_%d", i))
		if err := copyDir(feature.CachePath, destDir); err != nil {
			return fmt.Errorf("failed to copy feature %s: %w", feature.ID, err)
		}
	}

	return nil
}

// writeFile writes data to a file.
func writeFile(path string, data []byte) error {
	return writeFileAtomic(path, data, 0644)
}

// writeFileAtomic writes data to a file atomically using os package.
func writeFileAtomic(path string, data []byte, perm uint32) error {
	// Simple implementation - just write directly
	// In production, use atomic write with temp file
	f, err := createFile(path)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.Write(data)
	return err
}

// createFile creates a file for writing.
func createFile(path string) (*fileWriter, error) {
	return &fileWriter{path: path, data: make([]byte, 0)}, nil
}

type fileWriter struct {
	path string
	data []byte
}

func (f *fileWriter) Write(p []byte) (int, error) {
	f.data = append(f.data, p...)
	return len(p), nil
}

func (f *fileWriter) Close() error {
	return writeFileOS(f.path, f.data)
}

// copyDir copies a directory recursively.
func copyDir(src, dst string) error {
	return copyDirRecursive(src, dst)
}
