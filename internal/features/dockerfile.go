package features

import (
	"fmt"
	"path/filepath"
	"strings"
)

// DockerfileGenerator generates Dockerfiles for feature installation.
type DockerfileGenerator struct {
	baseImage      string
	features       []*Feature
	buildDir       string
	remoteUser     string
	remoteUserHome string
}

// NewDockerfileGenerator creates a new Dockerfile generator.
// remoteUser is the configured remoteUser from devcontainer.json (defaults to "root" if empty).
func NewDockerfileGenerator(baseImage string, features []*Feature, buildDir, remoteUser string) *DockerfileGenerator {
	if remoteUser == "" {
		remoteUser = "root"
	}
	remoteUserHome := "/root"
	if remoteUser != "root" {
		remoteUserHome = "/home/" + remoteUser
	}
	return &DockerfileGenerator{
		baseImage:      baseImage,
		features:       features,
		buildDir:       buildDir,
		remoteUser:     remoteUser,
		remoteUserHome: remoteUserHome,
	}
}

// Generate creates the Dockerfile content.
func (g *DockerfileGenerator) Generate() string {
	var sb strings.Builder

	// BuildKit syntax directive (must be first line for SSH mount support)
	sb.WriteString("# syntax=docker/dockerfile:1\n")

	// Header comment
	sb.WriteString("# Generated by dcx - do not edit\n")
	sb.WriteString("# This Dockerfile installs devcontainer features on the base image\n\n")

	// Start from base image
	sb.WriteString(fmt.Sprintf("FROM %s\n\n", g.baseImage))

	// Set build-time arguments for feature installation
	sb.WriteString("# Feature installation environment\n")
	sb.WriteString(fmt.Sprintf("ARG _REMOTE_USER=%s\n", g.remoteUser))
	sb.WriteString(fmt.Sprintf("ARG _REMOTE_USER_HOME=%s\n\n", g.remoteUserHome))

	// Install each feature
	for i, feature := range g.features {
		g.generateFeatureInstall(&sb, feature, i)
	}

	// Collect environment variables from all features
	envVars := g.collectContainerEnv()
	if len(envVars) > 0 {
		sb.WriteString("# Container environment from features\n")
		for key, value := range envVars {
			sb.WriteString(fmt.Sprintf("ENV %s=%s\n", key, shellQuote(value)))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateFeatureInstall generates the installation commands for a single feature.
func (g *DockerfileGenerator) generateFeatureInstall(sb *strings.Builder, feature *Feature, index int) {
	featureName := feature.ID
	if feature.Metadata != nil && feature.Metadata.Name != "" {
		featureName = feature.Metadata.Name
	}

	sb.WriteString(fmt.Sprintf("# Feature %d: %s\n", index+1, featureName))

	// Copy feature files
	featureDir := fmt.Sprintf("feature_%d", index)
	sb.WriteString(fmt.Sprintf("COPY %s /tmp/dcx-features/%s\n", featureDir, featureDir))

	// Set option environment variables as build args (not persisted in image)
	envVars := feature.GetEnvVars()
	if len(envVars) > 0 {
		for key, value := range envVars {
			sb.WriteString(fmt.Sprintf("ARG %s=%s\n", key, shellQuote(value)))
		}
	}

	// Run install.sh - use the script's shebang (features typically require bash)
	sb.WriteString(fmt.Sprintf("RUN chmod +x /tmp/dcx-features/%s/install.sh && \\\n", featureDir))
	sb.WriteString(fmt.Sprintf("    cd /tmp/dcx-features/%s && \\\n", featureDir))
	sb.WriteString("    ./install.sh && \\\n")
	sb.WriteString(fmt.Sprintf("    rm -rf /tmp/dcx-features/%s\n\n", featureDir))
}

// collectContainerEnv collects all containerEnv values from features.
func (g *DockerfileGenerator) collectContainerEnv() map[string]string {
	env := make(map[string]string)

	for _, feature := range g.features {
		if feature.Metadata == nil {
			continue
		}
		for key, value := range feature.Metadata.ContainerEnv {
			env[key] = value
		}
	}

	return env
}

// GetFeaturePaths returns the source paths for features to be copied into the build context.
func (g *DockerfileGenerator) GetFeaturePaths() []FeatureCopyPath {
	paths := make([]FeatureCopyPath, len(g.features))

	for i, feature := range g.features {
		paths[i] = FeatureCopyPath{
			Source: feature.CachePath,
			Dest:   fmt.Sprintf("feature_%d", i),
		}
	}

	return paths
}

// FeatureCopyPath represents a feature directory to copy into the build context.
type FeatureCopyPath struct {
	Source string // Absolute path to feature directory
	Dest   string // Destination directory name in build context
}

// CollectCapabilities collects all capabilities needed by features.
func CollectCapabilities(features []*Feature) []string {
	capMap := make(map[string]bool)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, cap := range feature.Metadata.CapAdd {
			capMap[cap] = true
		}
	}

	caps := make([]string, 0, len(capMap))
	for cap := range capMap {
		caps = append(caps, cap)
	}

	return caps
}

// CollectSecurityOpts collects all security options needed by features.
func CollectSecurityOpts(features []*Feature) []string {
	optMap := make(map[string]bool)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, opt := range feature.Metadata.SecurityOpt {
			optMap[opt] = true
		}
	}

	opts := make([]string, 0, len(optMap))
	for opt := range optMap {
		opts = append(opts, opt)
	}

	return opts
}

// NeedsPrivileged returns true if any feature requires privileged mode.
func NeedsPrivileged(features []*Feature) bool {
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Privileged {
			return true
		}
	}
	return false
}

// NeedsInit returns true if any feature requires init.
func NeedsInit(features []*Feature) bool {
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Init {
			return true
		}
	}
	return false
}

// CollectMounts collects all mounts needed by features.
func CollectMounts(features []*Feature) []string {
	mounts := make([]string, 0)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, m := range feature.Metadata.Mounts {
			mounts = append(mounts, m.String())
		}
	}

	return mounts
}

// CollectContainerEnv collects all container environment variables from features.
func CollectContainerEnv(features []*Feature) map[string]string {
	env := make(map[string]string)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for key, value := range feature.Metadata.ContainerEnv {
			env[key] = value
		}
	}

	return env
}

// shellQuote quotes a string for use in shell.
func shellQuote(s string) string {
	// If string contains no special characters, return as-is
	if !strings.ContainsAny(s, " \t\n\"'$`\\!") {
		return s
	}

	// Use double quotes and escape special characters
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "$", "\\$")
	s = strings.ReplaceAll(s, "`", "\\`")

	return fmt.Sprintf("\"%s\"", s)
}

// PrepareBuildContext creates the build context directory with feature files.
func PrepareBuildContext(buildDir string, features []*Feature, dockerfile string) error {
	// Write Dockerfile
	dockerfilePath := filepath.Join(buildDir, "Dockerfile.dcx-features")
	if err := writeFile(dockerfilePath, []byte(dockerfile)); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	// Copy feature directories
	for i, feature := range features {
		destDir := filepath.Join(buildDir, fmt.Sprintf("feature_%d", i))
		if err := copyDir(feature.CachePath, destDir); err != nil {
			return fmt.Errorf("failed to copy feature %s: %w", feature.ID, err)
		}
	}

	return nil
}

// writeFile writes data to a file.
func writeFile(path string, data []byte) error {
	return writeFileAtomic(path, data, 0644)
}

// writeFileAtomic writes data to a file atomically using os package.
func writeFileAtomic(path string, data []byte, perm uint32) error {
	// Simple implementation - just write directly
	// In production, use atomic write with temp file
	f, err := createFile(path)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.Write(data)
	return err
}

// createFile creates a file for writing.
func createFile(path string) (*fileWriter, error) {
	return &fileWriter{path: path, data: make([]byte, 0)}, nil
}

type fileWriter struct {
	path string
	data []byte
}

func (f *fileWriter) Write(p []byte) (int, error) {
	f.data = append(f.data, p...)
	return len(p), nil
}

func (f *fileWriter) Close() error {
	return writeFileOS(f.path, f.data)
}

// copyDir copies a directory recursively.
func copyDir(src, dst string) error {
	return copyDirRecursive(src, dst)
}
