package features

import (
	"fmt"
	"strings"

	"github.com/griffithind/dcx/internal/common"
)

// DockerfileGenerator generates Dockerfiles for feature installation.
type DockerfileGenerator struct {
	baseImage         string
	features          []*Feature
	buildDir          string
	remoteUser        string
	remoteUserHome    string
	containerUser     string
	containerUserHome string
	metadata          string
}

// NewDockerfileGenerator creates a new Dockerfile generator.
// remoteUser is the configured remoteUser from devcontainer.json (defaults to containerUser if empty).
// containerUser is the container's user account (defaults to "root" if empty).
func NewDockerfileGenerator(baseImage string, features []*Feature, buildDir, remoteUser, containerUser string) *DockerfileGenerator {
	// Container user defaults to root
	if containerUser == "" {
		containerUser = "root"
	}

	// Remote user defaults to container user per spec
	if remoteUser == "" {
		remoteUser = containerUser
	}

	// Note: Home directories are resolved dynamically at build time using getent
	// We set static defaults here that will be overridden by the dynamic resolution
	containerUserHome := common.GetDefaultHomeDir(containerUser)
	remoteUserHome := common.GetDefaultHomeDir(remoteUser)

	return &DockerfileGenerator{
		baseImage:         baseImage,
		features:          features,
		buildDir:          buildDir,
		remoteUser:        remoteUser,
		remoteUserHome:    remoteUserHome,
		containerUser:     containerUser,
		containerUserHome: containerUserHome,
	}
}

// SetMetadata sets the devcontainer.metadata label to embed in the image.
func (g *DockerfileGenerator) SetMetadata(metadata string) {
	g.metadata = metadata
}

// Generate creates the Dockerfile content.
// Uses BuildKit build contexts with RUN --mount for efficient feature installation.
func (g *DockerfileGenerator) Generate() string {
	var sb strings.Builder

	// Syntax directive required for RUN --mount
	sb.WriteString("# syntax=docker/dockerfile:1.4\n")
	sb.WriteString("# Generated by dcx - do not edit\n")
	sb.WriteString("# This Dockerfile installs devcontainer features using BuildKit build contexts\n\n")

	// Start from base image
	sb.WriteString(fmt.Sprintf("FROM %s\n\n", g.baseImage))

	// Set build-time arguments for feature installation per devcontainer spec
	// The default home directories are provided as ARG defaults, but we use
	// dynamic resolution via getent to handle non-standard home directories.
	sb.WriteString("# Feature installation environment\n")
	sb.WriteString(fmt.Sprintf("ARG _REMOTE_USER=%s\n", g.remoteUser))
	sb.WriteString(fmt.Sprintf("ARG _REMOTE_USER_HOME=%s\n", g.remoteUserHome))
	sb.WriteString(fmt.Sprintf("ARG _CONTAINER_USER=%s\n", g.containerUser))
	sb.WriteString(fmt.Sprintf("ARG _CONTAINER_USER_HOME=%s\n\n", g.containerUserHome))

	// Create features temp directory and copy builtin.env from build context
	sb.WriteString("# Setup features directory and copy environment file\n")
	sb.WriteString("RUN mkdir -p /tmp/dcx-features\n")
	sb.WriteString("COPY --from=dev_containers_feature_content_source builtin.env /tmp/dcx-features/\n\n")

	// Install each feature using RUN --mount
	for i, feature := range g.features {
		g.generateFeatureInstall(&sb, feature, i)
	}

	// Collect environment variables from all features
	envVars := g.collectContainerEnv()
	if len(envVars) > 0 {
		sb.WriteString("# Container environment from features\n")
		for key, value := range envVars {
			sb.WriteString(fmt.Sprintf("ENV %s=%s\n", key, common.ShellQuote(value)))
		}
		sb.WriteString("\n")
	}

	// Add devcontainer.metadata label per spec
	if g.metadata != "" {
		sb.WriteString("# Devcontainer metadata (per spec)\n")
		sb.WriteString(fmt.Sprintf("LABEL devcontainer.metadata=%s\n\n", common.LabelQuote(g.metadata)))
	}

	return sb.String()
}

// generateFeatureInstall generates the installation commands for a single feature.
// Uses RUN --mount to efficiently mount feature content from build context,
// following the devcontainer reference implementation pattern.
func (g *DockerfileGenerator) generateFeatureInstall(sb *strings.Builder, feature *Feature, index int) {
	featureName := feature.ID
	featureID := ""
	featureVersion := ""
	featureDescription := ""

	if feature.Metadata != nil {
		if feature.Metadata.Name != "" {
			featureName = feature.Metadata.Name
		}
		featureID = feature.Metadata.ID
		featureVersion = feature.Metadata.Version
		featureDescription = feature.Metadata.Description
	}

	fmt.Fprintf(sb, "# Feature %d: %s\n", index+1, featureName)

	featureDir := fmt.Sprintf("feature_%d", index)

	// Set option environment variables as build args (not persisted in image)
	envVars := feature.GetEnvVars()
	if len(envVars) > 0 {
		for key, value := range envVars {
			fmt.Fprintf(sb, "ARG %s=%s\n", key, common.ShellQuote(value))
		}
	}

	// Escape values for shell
	escapedName := common.ShellEscapeSingleQuote(featureName)
	escapedID := common.ShellEscapeSingleQuote(featureID)
	escapedVersion := common.ShellEscapeSingleQuote(featureVersion)
	escapedDesc := common.ShellEscapeSingleQuote(featureDescription)

	// Use RUN --mount to bind mount feature content from build context
	// This is more efficient than COPY as content is not persisted in the layer
	fmt.Fprintf(sb, "RUN --mount=type=bind,from=dev_containers_feature_content_source,source=%s,target=/tmp/build-features-src/%s \\\n", featureDir, featureDir)
	fmt.Fprintf(sb, "    cp -ar /tmp/build-features-src/%s /tmp/dcx-features/%s && \\\n", featureDir, featureDir)
	fmt.Fprintf(sb, "    chmod -R 0755 /tmp/dcx-features/%s && \\\n", featureDir)
	fmt.Fprintf(sb, "    cd /tmp/dcx-features/%s && \\\n", featureDir)
	sb.WriteString("    set -a && . /tmp/dcx-features/builtin.env && set +a && \\\n")
	sb.WriteString("    if [ -f ./devcontainer-features.env ]; then . ./devcontainer-features.env; fi && \\\n")
	sb.WriteString("    echo '===========================================================================' && \\\n")
	fmt.Fprintf(sb, "    echo 'Feature       : %s' && \\\n", escapedName)
	fmt.Fprintf(sb, "    echo 'Description   : %s' && \\\n", escapedDesc)
	fmt.Fprintf(sb, "    echo 'Id            : %s' && \\\n", escapedID)
	fmt.Fprintf(sb, "    echo 'Version       : %s' && \\\n", escapedVersion)
	sb.WriteString("    echo '===========================================================================' && \\\n")
	sb.WriteString("    chmod +x ./install.sh && \\\n")
	fmt.Fprintf(sb, "    (./install.sh || { echo 'ERROR: Feature \"%s\" (%s) failed to install!'; exit 1; }) && \\\n", escapedName, escapedID)
	fmt.Fprintf(sb, "    rm -rf /tmp/dcx-features/%s\n\n", featureDir)
}

// collectContainerEnv collects all containerEnv values from features.
func (g *DockerfileGenerator) collectContainerEnv() map[string]string {
	env := make(map[string]string)

	for _, feature := range g.features {
		if feature.Metadata == nil {
			continue
		}
		for key, value := range feature.Metadata.ContainerEnv {
			env[key] = value
		}
	}

	return env
}

// GetFeaturePaths returns the source paths for features to be copied into the build context.
func (g *DockerfileGenerator) GetFeaturePaths() []FeatureCopyPath {
	paths := make([]FeatureCopyPath, len(g.features))

	for i, feature := range g.features {
		paths[i] = FeatureCopyPath{
			Source: feature.CachePath,
			Dest:   fmt.Sprintf("feature_%d", i),
		}
	}

	return paths
}

// FeatureCopyPath represents a feature directory to copy into the build context.
type FeatureCopyPath struct {
	Source string // Absolute path to feature directory
	Dest   string // Destination directory name in build context
}

// collectUniqueStrings is a generic helper to collect unique strings from features.
func collectUniqueStrings(features []*Feature, getStrings func(*FeatureMetadata) []string) []string {
	seen := make(map[string]bool)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, s := range getStrings(feature.Metadata) {
			seen[s] = true
		}
	}

	result := make([]string, 0, len(seen))
	for s := range seen {
		result = append(result, s)
	}

	return result
}

// CollectCapabilities collects all capabilities needed by features.
func CollectCapabilities(features []*Feature) []string {
	return collectUniqueStrings(features, func(m *FeatureMetadata) []string {
		return m.CapAdd
	})
}

// CollectSecurityOpts collects all security options needed by features.
func CollectSecurityOpts(features []*Feature) []string {
	return collectUniqueStrings(features, func(m *FeatureMetadata) []string {
		return m.SecurityOpt
	})
}

// NeedsPrivileged returns true if any feature requires privileged mode.
func NeedsPrivileged(features []*Feature) bool {
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Privileged {
			return true
		}
	}
	return false
}

// GetPrivilegedFeatures returns the names of features that require privileged mode.
func GetPrivilegedFeatures(features []*Feature) []string {
	var names []string
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Privileged {
			name := feature.Metadata.Name
			if name == "" {
				name = feature.Metadata.ID
			}
			names = append(names, name)
		}
	}
	return names
}

// SecurityRequirements summarizes the security requirements from features.
type SecurityRequirements struct {
	Privileged   bool
	Capabilities []string
	SecurityOpts []string
	FeatureNames []string // Features that require elevated privileges
}

// GetSecurityRequirements returns all security requirements from features.
func GetSecurityRequirements(features []*Feature) SecurityRequirements {
	reqs := SecurityRequirements{}

	capMap := make(map[string]bool)
	optMap := make(map[string]bool)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}

		name := feature.Metadata.Name
		if name == "" {
			name = feature.Metadata.ID
		}

		if feature.Metadata.Privileged {
			reqs.Privileged = true
			reqs.FeatureNames = append(reqs.FeatureNames, name+" (privileged)")
		}

		for _, cap := range feature.Metadata.CapAdd {
			if !capMap[cap] {
				capMap[cap] = true
				reqs.Capabilities = append(reqs.Capabilities, cap)
			}
		}

		for _, opt := range feature.Metadata.SecurityOpt {
			if !optMap[opt] {
				optMap[opt] = true
				reqs.SecurityOpts = append(reqs.SecurityOpts, opt)
			}
		}
	}

	return reqs
}

// NeedsInit returns true if any feature requires init.
func NeedsInit(features []*Feature) bool {
	for _, feature := range features {
		if feature.Metadata != nil && feature.Metadata.Init {
			return true
		}
	}
	return false
}

// MountSubstituteFunc is a function that performs variable substitution on mount strings.
type MountSubstituteFunc func(string) string

// CollectMounts collects all mounts needed by features.
// If substitute is provided, it will be applied to each mount string for variable substitution.
func CollectMounts(features []*Feature, substitute MountSubstituteFunc) []string {
	mounts := make([]string, 0)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for _, m := range feature.Metadata.Mounts {
			mount := m.String()
			if substitute != nil {
				mount = substitute(mount)
			}
			mounts = append(mounts, mount)
		}
	}

	return mounts
}

// CollectContainerEnv collects all container environment variables from features.
func CollectContainerEnv(features []*Feature) map[string]string {
	env := make(map[string]string)

	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		for key, value := range feature.Metadata.ContainerEnv {
			env[key] = value
		}
	}

	return env
}

// FeatureHook represents a lifecycle hook from a feature.
type FeatureHook struct {
	// FeatureID identifies which feature this hook is from
	FeatureID string
	// FeatureName is the display name of the feature
	FeatureName string
	// Command is the command specification (string, array, or map)
	Command interface{}
}

// HookType represents a lifecycle hook type.
type HookType string

const (
	HookOnCreate      HookType = "onCreateCommand"
	HookUpdateContent HookType = "updateContentCommand"
	HookPostCreate    HookType = "postCreateCommand"
	HookPostStart     HookType = "postStartCommand"
	HookPostAttach    HookType = "postAttachCommand"
)

// CollectHooks collects lifecycle hooks of the specified type from features.
// This is the generic form that can be used instead of the specific CollectXCommands functions.
func CollectHooks(features []*Feature, hookType HookType) []FeatureHook {
	var getter func(*FeatureMetadata) interface{}

	switch hookType {
	case HookOnCreate:
		getter = func(m *FeatureMetadata) interface{} { return m.OnCreateCommand }
	case HookUpdateContent:
		getter = func(m *FeatureMetadata) interface{} { return m.UpdateContentCommand }
	case HookPostCreate:
		getter = func(m *FeatureMetadata) interface{} { return m.PostCreateCommand }
	case HookPostStart:
		getter = func(m *FeatureMetadata) interface{} { return m.PostStartCommand }
	case HookPostAttach:
		getter = func(m *FeatureMetadata) interface{} { return m.PostAttachCommand }
	default:
		return nil
	}

	return collectHooks(features, getter)
}

// collectHooks is a generic helper to collect lifecycle hooks from features.
func collectHooks(features []*Feature, getCommand func(*FeatureMetadata) interface{}) []FeatureHook {
	var hooks []FeatureHook
	for _, feature := range features {
		if feature.Metadata == nil {
			continue
		}
		cmd := getCommand(feature.Metadata)
		if cmd == nil {
			continue
		}
		name := feature.Metadata.Name
		if name == "" {
			name = feature.Metadata.ID
		}
		hooks = append(hooks, FeatureHook{
			FeatureID:   feature.Metadata.ID,
			FeatureName: name,
			Command:     cmd,
		})
	}
	return hooks
}

// CollectOnCreateCommands collects all onCreateCommand hooks from features.
// These run after feature installation, in feature order.
func CollectOnCreateCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookOnCreate)
}

// CollectPostCreateCommands collects all postCreateCommand hooks from features.
// These run after all features are installed and container is ready.
func CollectPostCreateCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookPostCreate)
}

// CollectPostStartCommands collects all postStartCommand hooks from features.
// These run on each container start.
func CollectPostStartCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookPostStart)
}

// CollectUpdateContentCommands collects all updateContentCommand hooks from features.
// These run after onCreateCommand and before postCreateCommand.
func CollectUpdateContentCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookUpdateContent)
}

// CollectPostAttachCommands collects all postAttachCommand hooks from features.
// These run when attaching to the container.
func CollectPostAttachCommands(features []*Feature) []FeatureHook {
	return CollectHooks(features, HookPostAttach)
}
