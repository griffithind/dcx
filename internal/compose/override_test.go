package compose

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewOverrideGenerator(t *testing.T) {
	tests := []struct {
		name        string
		projectName string
		serviceName string
	}{
		{
			name:        "basic creation",
			projectName: "my-project",
			serviceName: "app",
		},
		{
			name:        "empty project name",
			projectName: "",
			serviceName: "app",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := NewOverrideGenerator(tt.projectName, tt.serviceName)
			require.NotNil(t, gen)
			assert.Equal(t, tt.projectName, gen.projectName)
			assert.Equal(t, tt.serviceName, gen.serviceName)
		})
	}
}

func TestOverrideGeneratorGenerate(t *testing.T) {
	tests := []struct {
		name         string
		serviceName  string
		config       OverrideConfig
		wantContains []string
		wantErr      bool
	}{
		{
			name:        "empty config",
			serviceName: "app",
			config:      OverrideConfig{},
			wantContains: []string{
				"# Generated by dcx",
				"services:",
				"app:",
			},
		},
		{
			name:        "with image",
			serviceName: "app",
			config: OverrideConfig{
				Image: "myimage:latest",
			},
			wantContains: []string{
				"image: myimage:latest",
			},
		},
		{
			name:        "with labels",
			serviceName: "app",
			config: OverrideConfig{
				Labels: map[string]string{
					"com.example.app": "test",
				},
			},
			wantContains: []string{
				"labels:",
				"com.example.app: test",
			},
		},
		{
			name:        "with environment",
			serviceName: "app",
			config: OverrideConfig{
				Environment: map[string]string{
					"FOO": "bar",
				},
			},
			wantContains: []string{
				"environment:",
				"FOO: bar",
			},
		},
		{
			name:        "with same host and container port",
			serviceName: "app",
			config: OverrideConfig{
				Ports: []PortConfig{
					{Host: 8080, Container: 8080},
				},
			},
			wantContains: []string{
				"ports:",
				"- \"8080\"",
			},
		},
		{
			name:        "with different host port",
			serviceName: "app",
			config: OverrideConfig{
				Ports: []PortConfig{
					{Host: 3000, Container: 8080},
				},
			},
			wantContains: []string{
				"ports:",
				"3000:8080",
			},
		},
		{
			name:        "with zero host port",
			serviceName: "app",
			config: OverrideConfig{
				Ports: []PortConfig{
					{Host: 0, Container: 8080},
				},
			},
			wantContains: []string{
				"ports:",
				"- \"8080\"",
			},
		},
		{
			name:        "with volumes",
			serviceName: "app",
			config: OverrideConfig{
				Volumes: []string{"/host:/container"},
			},
			wantContains: []string{
				"volumes:",
				"/host:/container",
			},
		},
		{
			name:        "with single command",
			serviceName: "app",
			config: OverrideConfig{
				Command: []string{"sleep infinity"},
			},
			wantContains: []string{
				"command: sleep infinity",
			},
		},
		{
			name:        "with multiple command args",
			serviceName: "app",
			config: OverrideConfig{
				Command: []string{"sleep", "infinity"},
			},
			wantContains: []string{
				"command:",
				"- sleep",
				"- infinity",
			},
		},
		{
			name:        "with single entrypoint",
			serviceName: "app",
			config: OverrideConfig{
				Entrypoint: []string{"/entrypoint.sh"},
			},
			wantContains: []string{
				"entrypoint: /entrypoint.sh",
			},
		},
		{
			name:        "with user",
			serviceName: "app",
			config: OverrideConfig{
				User: "vscode",
			},
			wantContains: []string{
				"user: vscode",
			},
		},
		{
			name:        "with working dir",
			serviceName: "app",
			config: OverrideConfig{
				WorkingDir: "/workspace",
			},
			wantContains: []string{
				"working_dir: /workspace",
			},
		},
		{
			name:        "full config",
			serviceName: "myapp",
			config: OverrideConfig{
				Image:       "node:18",
				Labels:      map[string]string{"env": "dev"},
				Environment: map[string]string{"NODE_ENV": "development"},
				Ports:       []PortConfig{{Host: 3000, Container: 3000}},
				Volumes:     []string{".:/app"},
				User:        "node",
				WorkingDir:  "/app",
			},
			wantContains: []string{
				"image: node:18",
				"labels:",
				"environment:",
				"ports:",
				"volumes:",
				"user: node",
				"working_dir: /app",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := NewOverrideGenerator("test-project", tt.serviceName)
			content, err := gen.Generate(tt.config)

			if tt.wantErr {
				require.Error(t, err)
				return
			}

			require.NoError(t, err)
			for _, want := range tt.wantContains {
				assert.Contains(t, content, want)
			}
		})
	}
}

func TestOverrideGeneratorGenerateString(t *testing.T) {
	gen := NewOverrideGenerator("test-project", "app")

	content := gen.GenerateString(OverrideConfig{
		Image: "alpine:latest",
	})

	assert.Contains(t, content, "image: alpine:latest")
}

func TestOverrideGeneratorWriteToFile(t *testing.T) {
	gen := NewOverrideGenerator("test-project", "app")

	tmpFile, err := os.CreateTemp("", "override-test-*.yml")
	require.NoError(t, err)
	tmpFile.Close()
	defer os.Remove(tmpFile.Name())

	err = gen.WriteToFile(OverrideConfig{
		Image: "alpine:latest",
	}, tmpFile.Name())
	require.NoError(t, err)

	content, err := os.ReadFile(tmpFile.Name())
	require.NoError(t, err)
	assert.Contains(t, string(content), "image: alpine:latest")
}

func TestOverrideGeneratorWriteToTempFile(t *testing.T) {
	gen := NewOverrideGenerator("test-project", "app")

	path, err := gen.WriteToTempFile(OverrideConfig{
		Image: "alpine:latest",
	})
	require.NoError(t, err)
	defer os.Remove(path)

	assert.True(t, strings.HasPrefix(path, os.TempDir()) || strings.Contains(path, "dcx-override"))

	content, err := os.ReadFile(path)
	require.NoError(t, err)
	assert.Contains(t, string(content), "image: alpine:latest")
}

func TestOverrideGeneratorGenerateWithLabels(t *testing.T) {
	gen := NewOverrideGenerator("test-project", "app")

	content := gen.GenerateWithLabels(
		"myimage:latest",
		map[string]string{"app": "test"},
		[]PortConfig{{Host: 8080, Container: 8080}},
		[]string{"/host:/container"},
	)

	assert.Contains(t, content, "image: myimage:latest")
	assert.Contains(t, content, "labels:")
	assert.Contains(t, content, "ports:")
	assert.Contains(t, content, "volumes:")
}

func TestMergeOverrideFiles(t *testing.T) {
	// Create a base compose file
	tmpBase, err := os.CreateTemp("", "compose-base-*.yml")
	require.NoError(t, err)
	defer os.Remove(tmpBase.Name())

	_, err = tmpBase.WriteString("services:\n  app:\n    image: alpine:latest\n")
	require.NoError(t, err)
	tmpBase.Close()

	overrideContent := "# Override\nservices:\n  app:\n    image: custom:latest\n"

	files, cleanup, err := MergeOverrideFiles([]string{tmpBase.Name()}, overrideContent)
	require.NoError(t, err)
	defer os.Remove(cleanup)

	assert.Len(t, files, 2)
	assert.Equal(t, tmpBase.Name(), files[0])

	// Verify override file was created
	content, err := os.ReadFile(cleanup)
	require.NoError(t, err)
	assert.Contains(t, string(content), "custom:latest")
}

func TestCreateOverrideFile(t *testing.T) {
	path, err := CreateOverrideFile("app", OverrideConfig{
		Image: "test:latest",
	})
	require.NoError(t, err)
	defer os.Remove(path)

	content, err := os.ReadFile(path)
	require.NoError(t, err)
	assert.Contains(t, string(content), "image: test:latest")
}

func TestGetOverrideFilePath(t *testing.T) {
	tests := []struct {
		name      string
		configDir string
		want      string
	}{
		{
			name:      "simple path",
			configDir: "/project/.devcontainer",
			want:      "/project/.devcontainer/.dcx-override.yml",
		},
		{
			name:      "root path",
			configDir: "/",
			want:      "/.dcx-override.yml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GetOverrideFilePath(tt.configDir)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestCleanupOverrideFile(t *testing.T) {
	t.Run("empty path", func(t *testing.T) {
		err := CleanupOverrideFile("")
		assert.NoError(t, err)
	})

	t.Run("non-existent file", func(t *testing.T) {
		err := CleanupOverrideFile("/non/existent/path.yml")
		assert.NoError(t, err)
	})

	t.Run("existing file", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("", "cleanup-test-*.yml")
		require.NoError(t, err)
		tmpFile.Close()

		err = CleanupOverrideFile(tmpFile.Name())
		assert.NoError(t, err)

		_, err = os.Stat(tmpFile.Name())
		assert.True(t, os.IsNotExist(err))
	})
}

func TestOverrideConfig(t *testing.T) {
	cfg := OverrideConfig{
		Image: "myimage:latest",
		Labels: map[string]string{
			"key": "value",
		},
		Environment: map[string]string{
			"FOO": "bar",
		},
		Ports: []PortConfig{
			{Host: 8080, Container: 80},
		},
		Volumes: []string{
			"/host:/container",
		},
		Command:    []string{"sleep", "infinity"},
		Entrypoint: []string{"/entrypoint.sh"},
		User:       "app",
		WorkingDir: "/app",
	}

	assert.Equal(t, "myimage:latest", cfg.Image)
	assert.Equal(t, "value", cfg.Labels["key"])
	assert.Equal(t, "bar", cfg.Environment["FOO"])
	assert.Len(t, cfg.Ports, 1)
	assert.Len(t, cfg.Volumes, 1)
	assert.Len(t, cfg.Command, 2)
	assert.Len(t, cfg.Entrypoint, 1)
	assert.Equal(t, "app", cfg.User)
	assert.Equal(t, "/app", cfg.WorkingDir)
}

func TestPortConfig(t *testing.T) {
	tests := []struct {
		name      string
		config    PortConfig
		wantHost  int
		wantCont  int
	}{
		{
			name:      "same ports",
			config:    PortConfig{Host: 8080, Container: 8080},
			wantHost:  8080,
			wantCont:  8080,
		},
		{
			name:      "different ports",
			config:    PortConfig{Host: 3000, Container: 8080},
			wantHost:  3000,
			wantCont:  8080,
		},
		{
			name:      "zero host port",
			config:    PortConfig{Host: 0, Container: 8080},
			wantHost:  0,
			wantCont:  8080,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.wantHost, tt.config.Host)
			assert.Equal(t, tt.wantCont, tt.config.Container)
		})
	}
}
