package compose

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// OverrideGenerator creates compose override files for dcx customizations.
type OverrideGenerator struct {
	projectName string
	serviceName string
}

// NewOverrideGenerator creates a new override generator.
func NewOverrideGenerator(projectName, serviceName string) *OverrideGenerator {
	return &OverrideGenerator{
		projectName: projectName,
		serviceName: serviceName,
	}
}

// OverrideConfig contains the configuration for generating an override file.
type OverrideConfig struct {
	// Image overrides the service image.
	Image string

	// Labels to add to the service.
	Labels map[string]string

	// Environment variables to add.
	Environment map[string]string

	// Ports to expose.
	Ports []PortConfig

	// Volumes to mount.
	Volumes []string

	// Command overrides the service command.
	Command []string

	// Entrypoint overrides the service entrypoint.
	Entrypoint []string

	// User sets the user to run as.
	User string

	// WorkingDir sets the working directory.
	WorkingDir string
}

// PortConfig represents a port configuration.
type PortConfig struct {
	Host      int
	Container int
}

// Generate creates the override YAML content.
func (g *OverrideGenerator) Generate(cfg OverrideConfig) (string, error) {
	// Build the override structure
	service := make(map[string]interface{})

	if cfg.Image != "" {
		service["image"] = cfg.Image
	}

	if len(cfg.Labels) > 0 {
		service["labels"] = cfg.Labels
	}

	if len(cfg.Environment) > 0 {
		service["environment"] = cfg.Environment
	}

	if len(cfg.Ports) > 0 {
		ports := make([]string, len(cfg.Ports))
		for i, p := range cfg.Ports {
			if p.Host == p.Container || p.Host == 0 {
				ports[i] = fmt.Sprintf("%d", p.Container)
			} else {
				ports[i] = fmt.Sprintf("%d:%d", p.Host, p.Container)
			}
		}
		service["ports"] = ports
	}

	if len(cfg.Volumes) > 0 {
		service["volumes"] = cfg.Volumes
	}

	if len(cfg.Command) > 0 {
		if len(cfg.Command) == 1 {
			service["command"] = cfg.Command[0]
		} else {
			service["command"] = cfg.Command
		}
	}

	if len(cfg.Entrypoint) > 0 {
		if len(cfg.Entrypoint) == 1 {
			service["entrypoint"] = cfg.Entrypoint[0]
		} else {
			service["entrypoint"] = cfg.Entrypoint
		}
	}

	if cfg.User != "" {
		service["user"] = cfg.User
	}

	if cfg.WorkingDir != "" {
		service["working_dir"] = cfg.WorkingDir
	}

	// Build the full override structure
	override := map[string]interface{}{
		"services": map[string]interface{}{
			g.serviceName: service,
		},
	}

	// Marshal to YAML
	content, err := yaml.Marshal(override)
	if err != nil {
		return "", fmt.Errorf("failed to marshal override: %w", err)
	}

	// Add header comment
	var sb strings.Builder
	sb.WriteString("# Generated by dcx - do not edit\n")
	sb.Write(content)

	return sb.String(), nil
}

// GenerateString creates the override YAML content as a string.
// This is a convenience method that wraps Generate.
func (g *OverrideGenerator) GenerateString(cfg OverrideConfig) string {
	content, err := g.Generate(cfg)
	if err != nil {
		return ""
	}
	return content
}

// WriteToFile writes the override to a file.
func (g *OverrideGenerator) WriteToFile(cfg OverrideConfig, path string) error {
	content, err := g.Generate(cfg)
	if err != nil {
		return err
	}

	return os.WriteFile(path, []byte(content), 0644)
}

// WriteToTempFile writes the override to a temporary file.
func (g *OverrideGenerator) WriteToTempFile(cfg OverrideConfig) (string, error) {
	content, err := g.Generate(cfg)
	if err != nil {
		return "", err
	}

	tmpFile, err := os.CreateTemp("", "dcx-override-*.yml")
	if err != nil {
		return "", fmt.Errorf("failed to create temp file: %w", err)
	}

	if _, err := tmpFile.WriteString(content); err != nil {
		tmpFile.Close()
		os.Remove(tmpFile.Name())
		return "", fmt.Errorf("failed to write temp file: %w", err)
	}

	tmpFile.Close()
	return tmpFile.Name(), nil
}

// GenerateWithLabels creates an override with dcx labels applied.
func (g *OverrideGenerator) GenerateWithLabels(
	image string,
	labels map[string]string,
	ports []PortConfig,
	volumes []string,
) string {
	return g.GenerateString(OverrideConfig{
		Image:   image,
		Labels:  labels,
		Ports:   ports,
		Volumes: volumes,
	})
}

// MergeOverrideFiles merges multiple compose files into a single project path list.
// The returned list can be passed to LoadProject.
func MergeOverrideFiles(baseFiles []string, overrideContent string) ([]string, string, error) {
	// Write override to temp file
	tmpFile, err := os.CreateTemp("", "dcx-override-*.yml")
	if err != nil {
		return nil, "", fmt.Errorf("failed to create temp file: %w", err)
	}

	if _, err := tmpFile.WriteString(overrideContent); err != nil {
		tmpFile.Close()
		os.Remove(tmpFile.Name())
		return nil, "", fmt.Errorf("failed to write temp file: %w", err)
	}
	tmpFile.Close()

	// Return merged list with cleanup path
	files := make([]string, len(baseFiles)+1)
	copy(files, baseFiles)
	files[len(files)-1] = tmpFile.Name()

	return files, tmpFile.Name(), nil
}

// CreateOverrideFile creates a temporary override file and returns its path.
// The caller is responsible for removing the file when done.
func CreateOverrideFile(serviceName string, cfg OverrideConfig) (string, error) {
	gen := NewOverrideGenerator("", serviceName)
	return gen.WriteToTempFile(cfg)
}

// GetOverrideFilePath returns the standard override file path for a config directory.
func GetOverrideFilePath(configDir string) string {
	return filepath.Join(configDir, ".dcx-override.yml")
}

// CleanupOverrideFile removes an override file if it exists.
func CleanupOverrideFile(path string) error {
	if path == "" {
		return nil
	}
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil
	}
	return os.Remove(path)
}
